<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Great Reef Census: Reefs</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/1.11.0/mapbox-gl.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/1.11.0/mapbox-gl.js"></script>
  <script src="https://unpkg.com/pbf@3.0.5/dist/pbf.js"></script>
  <script src="https://unpkg.com/geobuf@3.0.1/dist/geobuf.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.0/nouislider.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.0/nouislider.min.js"></script>
</head>
<body>
<div class="map">
  <div id="map" width="100%" height="100%"></div>
  <aside class="meta">
    <h1 class="meta-depth"></h1>
  </aside>
  <div class="search">
    <input class="search-input" placeholder="Search for a reef or island">
    <ul class="search-results"></ul>
  </div>
  <aside class="filter" style="display:none">
    <div class="filter-items">
      <header>Data Highlight</header>

      <div class="filter-items--content">
        <h3>GBRMPA identified reefs</h3>
        <h4>Resilience</h4>
        <label><input class="filter-item" data-type="status" data-value="hd" data-title="High Disturbance" data-colour="#FA0" type="checkbox"><strong>HD</strong> <u>H</u>igh risk of <u>d</u>isturbance</label>
        <label><input class="filter-item" data-type="status" data-value="ld" data-title="Low Disturbance" data-colour="#04B" type="checkbox"><strong>LD</strong> <u>L</u>ow risk of <u>d</u>isturbance</label>
        <label><input class="filter-item" data-type="status" data-value="hr" data-title="High Recovery" data-colour="#0B5" type="checkbox"><strong>HR</strong> <u>H</u>igh <u>r</u>ecovery potential</label>
        <label><input class="filter-item" data-type="status" data-value="lr" data-title="Low Recovery" data-colour="#F60" type="checkbox"><strong>LR</strong> <u>L</u>ow <u>r</u>ecovery potential</label>

        <h4>Monitoring</h4>
        <label><input class="filter-item" data-type="survey" data-key="Un" data-title="Unsurveyed" data-colour="#CAC" type="checkbox"><strong><u>Un</u></strong>surveyed (targeted)</label>
        <label><input class="filter-item" data-type="survey" data-key="Mo" data-title="Monitored" data-value="aims|mmp|bzgz" data-colour="#0AC" type="checkbox"><strong><u>Mo</u></strong>nitored (LTMP, MMP, BZGZ)</label>
        <label><input class="filter-item" data-type="survey" data-key="Su" data-title="Surveyed" data-value="cb|eotr" data-colour="#AC0" type="checkbox"><strong><u>Su</u></strong>rveyed (Bleaching Response, EOTR)</label>

        <h3>Other identified reefs</h3>
        <label><input class="filter-item" data-type="attr" data-key="Key" data-value="keysourcereef" data-title="Key Source Reef" data-colour="#50F" type="checkbox"><strong><u>Key</u></strong> Source Reefs</label>

        <section id="filter-analysis">

          <h3>Reef Importance Analysis <abbr tabindex="0" class="c-info"><em>Reefs are evaluated and scored by total larval enrichment potential versus 'neediness' of neighbouring reefs. A second component of the score simplifies connectivity considerations, counting only the number of connected 'needy' reefs (&lt; 20% coral cover). Combined scores are generated on both a reef-wide and per-sector scale. Source: Pete Mumby</em></abbr></h3>


          <h4 class="label">Score per sector <abbr tabindex="0" class="c-info"><em>Scores for each reef are scaled and applied per AIMS sector</em></abbr></h4>
          
          <span class="label"><strong>Importance</strong> <abbr tabindex="0" class="c-info"><em>The sum of larval enhancement (implicitly counting the number of connected reefs), and number of reefs in need.</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="i" data-min="0" data-max="2" data-type="importance_sector"></div>
          
          <span class="label"><strong>Importance (10% classes)</strong> <abbr tabindex="0" class="c-info"><em>Importance scores in each sector sorted in equal-sized chunks, where a score of 1 is in the bottom 10% of values in the sector and a score of 10 is in the top 10% of values.</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="i10" data-type="importance_10_sector" data-step="1" data-min="1" data-max="10" data-format="i"></div>

          <span class="label"><strong>Larval enrichment</strong> <abbr tabindex="0" class="c-info"><em>Examines the contribution of each reef to the supply of other reefs in need.</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="e" data-type="enrichment_sector"></div>

          <span class="label"><strong>Connectivity</strong> <abbr tabindex="0" class="c-info"><em>The second component of the score examines how many 'needy' reefs (&lt; 20% coral cover) are served by each reef</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="c" data-type="reefs_supplied_sector"></div>

          <h4 class="label">GBR score <abbr tabindex="0" class="c-info"><em>Scores for each reef at whole-of-reef scale</em></abbr></h4>

          <span class="label"><strong>Overall importance score</strong> <abbr tabindex="0" class="c-info"><em>Final metric applied (0-2) without prioritisation for individual sectors. While this predicts the best of the GBR overall, it may neglect reefs that are locally important but not significant at whole-of-reef scale.</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="s" data-min="0" data-max="2" data-type="score"></div>

          <h4 class="label">Other metrics</h4>

          <span class="label"><strong>AIMS sector</strong> <output></output><output></output></span>
          <div class="filter-range" data-key="a" data-type="aims_sector" data-step="1" data-min="1" data-max="11" data-format="i"></div>

          <span class="label"><strong>Predicted coral cover</strong> <abbr tabindex="0" class="c-info"><em>Source: ReefMod (UQ) Yves-Marie Bozec & Pete Mumby</em></abbr> <output></output><output></output></span>
          <div class="filter-range" data-key="p" data-type="coral_cover_2020" data-format="p"></div>

        </section>
      </div>

      <div class="filter-colours-key">
        <header>Data Filter and Colour Key <button class="reset-colours">Reset colours</button></header>
        <div class="filter-colours"></div>
      </div>
    </div>
  </aside>

  <a class="logo" href="https://citizensgbr.org">
    <img src="citizensgbr.svg">
  </a>
</div>
<script>
  const $el = {
    search: document.querySelector('.search-input'),
    searchResults: document.querySelector('.search-results'),
    filter: document.querySelector('.filter'),
    filters: [ ...document.querySelectorAll('.filter-item') ],
    ranges: [ ...document.querySelectorAll('.filter-range') ],
    colours: document.querySelector('.filter-colours'),
    coloursReset: document.querySelector('.reset-colours'),
    depth: document.querySelector('.meta-depth'),
  };
  const props = {
    colours: {},
    toggled: {},
    data: {
      gbrmpa: 'gbrmpa-reefs.json',
      keysourcereefs: 'source-reefs.json',
      priorityreefs: 'priority-reefs.csv',
      features: 'GBR-Features-points.pbf',
    },
    mapbox: {
      layer: {
        labels: 'gbr-labels',
        features: 'gbr-features',
        elevation: 'gbr-elevation',
      },
      style: 'mapbox://styles/citizensgbr/ckbfua7qs392g1inrykf56d9m',
      token: 'pk.eyJ1IjoiY2l0aXplbnNnYnIiLCJhIjoiY2poem8xZGk4MHo4NDNscGJsNGxzdHl6NiJ9._B84xipGf6JtH64bRGqlog&fresh=true',
    },
  };
  const fn = {
    init() {
      const updateFilter = fn.util.debounce(fn.onFilter, 500);
      const renderFilter = fn.util.debounce(fn.renderFilter, 500);

      $el.search.addEventListener('input', this.onSearch);
      $el.searchResults.addEventListener('click', this.onSearchResult);
      $el.filters.forEach($el => $el.addEventListener('change', this.onFilter));
      $el.colours.addEventListener('input', fn.util.throttle(fn.onToggle, 100));
      $el.coloursReset.addEventListener('click', (e) => {
        props.colours = {};
        try {
          delete localStorage.colours;
        } catch(e) {}
        delete e.target.parentElement.parentElement.dataset.colourised;
        fn.onFilter();
      });

      Promise.all(Object.keys(props.data).map(key => fetch(props.data[key])
        .then((e) => {
          const ext = props.data[key].replace(/^.*\.([^.]+)$/, '$1');
          if (ext === 'pbf') {
            return e.arrayBuffer().then(b =>
              geobuf.decode(new Pbf(b)).features);
          }
          if (ext === 'json') return e.json();
          // simple csv parse
          return e.text().then(csv =>
            csv.split('\r\n').reduce((_, row, i) =>
              row.split(',').reduce((__, cell, ii) => {
                if (!i) __.cols.push(cell);
                else {
                  if (__.list.length < i) __.list.push({});
                  __.list[i - 1][__.cols[ii]] = isNaN(cell) ? cell : +cell;
                }
                return __
              }, _), { cols: [], list: [] }).list);
        })
        .then(data => props.data[key] = data)))
      .then(this.onData);

      $el.ranges.forEach(($el) => {
        const format = $el.dataset.format || 'n';
        const min = +$el.dataset.min || 0;
        const max = +$el.dataset.max || 1;
        $el.dataset.min = min;
        $el.dataset.max = format === 'p' ? 100 : max;
        noUiSlider.create($el, {
          start: $el.dataset.start ? $el.dataset.start.split(',').map(n => +n) : [min, (format === 'p' ? 100 : max)],
          connect: true,
          tooltips: true,
          format: (() => {
            if (format === 'i') return { to: n => Math.round(n), from: n => +n };
            if (format === 'p') return { to: n => `${Math.round(n * 100)}%`, from: n => +n / 100 };
          })() || null,
          step: +$el.dataset.step || null,
          range: { min, max },
        });

        const outputs = $el.previousElementSibling.querySelectorAll('output');
        if (outputs.length) {
          $el.noUiSlider.on('update', (values, handle) => outputs[handle].innerHTML = values[handle]);
          $el.noUiSlider.on('change', updateFilter);
        }
      });

      mapboxgl.accessToken = props.mapbox.token;
      const map = props.map = new mapboxgl.Map({
        container: 'map',
        style: props.mapbox.style, // stylesheet location
        center: [146, -16.77], // starting position [lng, lat]
        zoom: 6, // starting zoom
        attributionControl: false,
      })
      .addControl(new mapboxgl.AttributionControl({
        customAttribution: '<a href="https://www.deepreef.org/bathymetry/65-3dgbr-bathy.html" title="Bathymetry data © www.deepreef.org 2017 (CC BY 4.0)">© www.deepreef.org</a> <a href="https://eatlas.org.au/data/uuid/ac8e8e4f-fc0e-4a01-9c3d-f27e4a8fac3c" title="GBR Features © GBRMPA 2014 (CC BY 4.0)">© GBRMPA</a> <a href="https://citizensgbr.org" title="Map and data modifications © CitizensGBR 2020 (CC BY 4.0)">© CitizensGBR</a> <a href="https://creativecommons.org/licenses/by/4.0/" title="Creative Commons Attribution 4.0 International"><strong>(CC BY 4.0)</strong></a>',
      }));
      map.once('render', map.resize);
      map.once('load', this.onLoad);

      map.on('click', () => delete $el.search.dataset.focus);

      map.on('move', renderFilter);
      map.on('sourcedata', renderFilter);
    
      // alert('TRY SETTING STATE TO A PROPERTY (e.g. ID) AND MATCHING THAT PROPERTY RATHER THAN HOVER = TRUE!')    
      
      // map.on('mousemove', props.mapbox.layer.elevation, this.onDepth);
      // map.on('mouseout', props.mapbox.layer.elevation, () => this.onDepth());
      map.on('mouseenter', props.mapbox.layer.elevation, () => {
        map.getCanvas().style.cursor = 'auto';
        map.on('mousemove', props.mapbox.layer.elevation, fn.onMove);
      });
      map.on('mouseleave', props.mapbox.layer.elevation, () => {
        map.getCanvas().style.cursor = '';
        map.off('mousemove', props.mapbox.layer.elevation, fn.onMove);
        fn.onMove();
      });
    },
    onData() {
      const meta = props.data.gbrmpa.meta;
      const gidMap = {};
      props.data.gbrmpa.list.forEach((item) => {
        if (!gidMap[item.gid]) gidMap[item.gid] = {};

        const data = gidMap[item.gid];
        data.gbrmpa = true;

        if ('mgmt' in item) data.mgmt = meta.mgmt[item.mgmt];
        if (item.status) data.status = item.status;
        if (item.zone) {
          data.zone = item.zone.map(zone => ({
            ...meta.zone[zone[0]],
            km2: zone[1] || 0,
          }));
        }
        if (item.survey) {
          data.survey = item.survey.map(i => meta.survey[i]);
        }
      });

      const missing = [];
      props.data.priorityreefs.forEach((item) => {
        if (!gidMap[item.gid]) {
          missing.push(item.gid);
          gidMap[item.gid] = {};
        }
        gidMap[item.gid].priorityreef = true;
        Object.assign(gidMap[item.gid], item);
      });

      props.data.keysourcereefs.forEach((gid) => {
        if (!gidMap[gid]) gidMap[gid] = {};
        gidMap[gid].keysourcereef = true;
      });

      props.data.features.forEach((feature, index) => {
        if (!feature.properties.gid) console.log(feature.properties);
        feature.properties.search = [feature.properties.name, feature.properties.gid].filter(v => v).join(' ');
        const lat = feature.geometry.coordinates[1];
        feature.properties.sector = (lat < -14.9 && 'Central') || (lat < -20.5 && 'Southern') || 'Northern';
        feature.properties.index = index;
        const missing_i = missing.indexOf(feature.properties.gid);
        if (missing_i >= 0) missing.splice(missing_i, 1);
        if (gidMap[feature.properties.gid]) {
          Object.assign(feature.properties, gidMap[feature.properties.gid], feature.properties);
        }
      });

      console.log('missing priority:', missing);


      fn.onSearch();
    },
    onFilter() {
      const filters = props.filters = fn.util.getFilters();
      const ranges = props.ranges = fn.util.getRanges();

      // const itemtest = { value: }
      // filters.survey.forEach(survey =>
      //       (survey.value
      //         ? itemtest.value && survey.value.find(v => itemtest.value.toLowerCase().indexOf(v) === 0)
      //         : !itemtest.survey) && matches.push(survey));

      // coral_cover_2020,karlo_shelf,aims_sector,score,enhancement_sector,reefs_supplied_sector,importance_sector,importance_10_sector

      const filtered = props.filtered = { gid: {}, filter: {} };
      props.data.features.forEach((feature, i) => {

        const item = feature.properties;
        if (!item.gbrmpa && !item.keysourcereef && !item.priorityreef) return;

        const isInvalid = Object.keys(ranges).find((type) => {
          return feature.properties.hasOwnProperty(type) && (feature.properties[type] < ranges[type].value[0]
          || feature.properties[type] > ranges[type].value[1]);
        });



        const matches = [];
        if (!isInvalid) {
          if (!Object.keys(filters).length && Object.keys(ranges).length) {
            matches.push({
              colour: ['A', 'A', '0'],
              title: 'Reef importance analysis filter',
              key: undefined,
              type: 'analysis',
              value: ['analysis filter'],
            });
          }
          if (filters.status && item.status) {
            filters.status.forEach(status =>
              item.status.toLowerCase().indexOf(status.value) >= 0 && matches.push(status));
          }
          if (filters.survey) {
            filters.survey.forEach(survey =>
              (survey.value
                ? item.survey && survey.value.find(v => item.survey.find(s => s.indexOf(v) === 0))
                : !item.survey) && matches.push(survey));
          }
          if (filters.attr) {
            filters.attr.forEach(attr =>
              item[attr.value] && matches.push(attr));
          }
        }

        if (matches.length) {

          const key = matches.reduce((_, m) => _ + (m.key || m.value), '').toLowerCase();
          if (!filtered.filter[key] ) {
            const label = matches.reduce((_, m, i) => {
              const l = m.key || [].concat(m.value).join('').toUpperCase();
              if(_.type !== m.type) {
                _.type = m.type;
                _.list.push(`<abbr title="${m.title}">${l}</abbr>`);
              } else {
                _.list[_.list.length - 1] += `<abbr title="${m.title}">${l}</abbr>`;
              }
              return _;
            }, { list: [] }).list.join(' / ');

            const colour = props.colours[key] || matches.reduce((_, m) =>
                m.colour.map((c, i) => _[i] + parseInt(c, 16)), [0, 0, 0])
              .reduce((_, c) => _ + (c % 16).toString(16), '#')
            filtered.filter[key] = {
              key,
              label,
              list: [],
              colour,
              colourFull: colour.length > 4 ? colour : colour.replace(/([a-f0-9])/gi, '$1$1'),
            }
          }
          filtered.active = true;
          filtered.gid[item.gid] = feature;
          filtered.filter[key].list.push(feature);
          feature.filter = filtered.filter[key];
        } else {
          filtered.reset = true;
        }
        // if (filters.status && item.status) filters.status.forEach(s => item.status.indexOf(s) === 0 && matches.push(s))
        // filters.

      });

      const filteredKeys = Object.keys(filtered.filter);
      if (filteredKeys.length) {
        $el.colours.parentElement.dataset.filtered = '';
        $el.filter.dataset.filtered = '';
      } else {
        delete $el.colours.parentElement.dataset.filtered; 
        delete $el.filter.dataset.filtered;
      }


      $el.colours.innerHTML = filteredKeys.map(key =>
        `<div class="filter-colours--item" style="background:${filtered.filter[key].colour}" ${props.toggled[key] ? 'data-toggled' : ''}>
          <label><input data-key="${key}" type="checkbox" ${props.toggled[key] ? '' : 'checked'}><strong>${filtered.filter[key].label}</strong><span>(${filtered.filter[key].list.length})</span></label><input data-key="${key}" type="color" value="${filtered.filter[key].colourFull}">
        </div>`).join('');

      fn.renderFilter();
      fn.util.updateState();
    },
    onToggle(e) {
      if (e.target.type === 'color') {
        const key = e.target.dataset.key;
        e.target.parentElement.style.background = e.target.value;
        e.target.parentElement.parentElement.parentElement.dataset.colourised = '';
        props.colours[key] = e.target.value;
        props.filtered.filter[key].colour = props.filtered.filter[key].colourFull = e.target.value;
      } else {      
        props.toggled[e.target.dataset.key] = !e.target.checked || null;
        if (e.target.checked) {
          delete e.target.parentElement.parentElement.dataset.toggled;
        } else {
          e.target.parentElement.parentElement.dataset.toggled = '';
        }
      }
      fn.util.updateState();
      fn.renderFilter();
    },
    renderFilter() {
      const filtered = props.filtered || {};
      if (filtered.running || (!filtered.active && !filtered.reset) || !props.mapbox.layer.ui) return;
      filtered.running = true;
      props.map.queryRenderedFeatures({ layers: [props.mapbox.layer.ui] })
      .forEach((feature) => {
        const state = props.map.getFeatureState(feature);
        const toggled = filtered.gid[feature.properties.gid] && props.toggled[filtered.gid[feature.properties.gid].filter.key] || null;
        // if (!filtered.gid[feature.properties.gid] !== !state.filtered || toggled != state.toggled) {
          props.map.setFeatureState(feature, {
            colour: filtered.gid[feature.properties.gid] ? filtered.gid[feature.properties.gid].filter.colour : null,
            filtered: filtered.gid[feature.properties.gid] ? feature.properties.gid : null,
            toggled,
          });
        // }
      });
      filtered.running = false;
    },
    onMove(e) {
      if (!e) {
        if (props.popup && props.popup.isOpen()) props.popup.remove();
        return;
      }

      const feature = e.features[0];
      const z = feature.properties.z;
      const depth = z > 0 ? z : (z <= -100 && `~${Math.max(200, -z + 10)}`)
        || `${-z}`;

      if (!props.popup) {
        props.popup = new mapboxgl.Popup({
          anchor: 'top-left',
          closeButton: false,
          closeOnClick: false,
          className: 'popup-hover',
          offset: [9, 18],
        });
        
        if (!props.popupElement) {
          props.popupElement = document.createElement('div');
          props.popupElement.className = 'popup-hover--content meta-item';
        }
        props.popup.setDOMContent(props.popupElement);
        props.popup.trackPointer();
      }
      
      // props.popup.setLngLat(e.lngLat)
      if (!props.popup.isOpen()) {
        props.popup.addTo(props.map);
      }

      props.popupElement.innerHTML = `<strong>Point ${z > 0 ? 'Elevation' : 'Depth'} ${depth}m</strong>
        <small>${e.lngLat.lng.toFixed(3)}, ${e.lngLat.lat.toFixed(3)}</small>`;

      if (props.feature && !props.popupReef) {
        const data = props.data.features.find(f => f.id === props.feature.properties.id);
        props.popupReef = new mapboxgl.Popup({
          anchor: 'bottom',
          closeButton: false,
          closeOnClick: false,
          className: 'popup-hover',
          offset: 50,
        }).setLngLat(data.geometry.coordinates);
        const $elPop = document.createElement('div');
        let html = `
        <h3>${props.feature.properties.name || [props.feature.properties.type, props.feature.properties.gid].join(' ')}</h3>
        <small>${(data.properties.zone || []).map((z, i, l) => z.name + (l.length > 1 && z.km2 ? ` (${Math.floor(100 * z.km2/data.properties.km2)}%)` : '')).join('<br>')}<br>${+props.feature.properties.km2.toFixed(2)}km²</small>
        <small>Modelling: ${data.properties.status}</small><br>
        <small>Monitoring programs: ${(data.properties.survey || ['none']).join(', ')}</small><br>
        <hr>
        <strong><small>Importance: ${data.properties.importance_sector.toFixed(2)} (top ${110 - data.properties.importance_10_sector * 10}% in sector ${data.properties.aims_sector})</small></strong>
        <small>Predicted coral cover: ${data.properties.coral_cover_2020.toFixed(1)}%</small><br>
        <small>Enrichment/connectivity score: ${data.properties.enrichment_sector.toFixed(2)}/${data.properties.reefs_supplied_sector.toFixed(2)}</small><br>
        <small>GBR score: ${data.properties.score.toFixed(2)}</small>
        `;
        $elPop.innerHTML = html;
        $elPop.className = 'popup-hover--content popup-hover--feature meta-item';
        props.popupReef.setDOMContent($elPop);
        props.popupReef.addTo(props.map);
      } else if (!props.feature && props.popupReef) {
        props.popupReef.remove();
        delete props.popupReef;
      }
    },
    onFeatureSelect(e) {
      const feature = props.data.features.find(feature => feature.properties.id === e.features[0].properties.id);
      fn.toggleFeature(feature);
    },
    onDepth(e) {
      const depth = e && e.features[0].properties.z * -1;
      $el.depth.innerHTML = isNaN(depth) ? '' : (depth === 100 && '>100') || depth;
    },
    onLoad() {
      props.map.easeTo({
        zoom: 10,
        bearing: 0,
        pitch: 40,
        duration: 2000,
        center: [146.265366, -16.778374] // Milln Reef,
      });

      const map = props.map;

      props.mapbox.layer.ui = 'gbr-features-ui';

      const layer = map.getLayer(props.mapbox.layer.features);

      props.map.addLayer({
        id: props.mapbox.layer.ui,
        type: 'fill-extrusion',
        source: 'composite',
        'source-layer': layer.sourceLayer,
        layout: {},
        paint: {
          'fill-extrusion-color': [
            'case',
            ['any',
              ['==', ['get', 'id'], ['feature-state', 'hover']],
              ['==', ['get', 'id'], ['feature-state', 'selected']],
              ['all', ['==', ['get', 'gid'], ['feature-state', 'filtered']], ['!', ['to-boolean', ['feature-state', 'toggled']]]],
            ],
            ['case',
              ['to-boolean', ['feature-state', 'hover']],
              '#FF0',
              ['case', 
                ['to-boolean', ['feature-state', 'selected']],
                '#F0F',
                ['feature-state', 'colour'],
              ],
            ],
            '#FFF'
          ],
          'fill-extrusion-opacity': 0.5,
          'fill-extrusion-base': 799,
          'fill-extrusion-height': [
            'case',
            ['any',
              ['==', ['get', 'id'], ['feature-state', 'hover']],
              ['==', ['get', 'id'], ['feature-state', 'selected']],
              ['all', ['==', ['get', 'gid'], ['feature-state', 'filtered']], ['!', ['to-boolean', ['feature-state', 'toggled']]]],
            ],
            ['case', ['to-boolean', ['feature-state', 'hover']], 1800, 1200],
            1
          ],
        }
      }, props.mapbox.layer.labels);


      map.on('click', props.mapbox.layer.features, (e) => {
        const feature = e.features[0];
        const state = map.getFeatureState(feature);
        const reset = state && state.selected === feature.properties.id;
        map.setFeatureState(feature, { selected: reset ? null : feature.properties.id });
      });


      props.feature;
      // map.on('mousemove', props.mapbox.layer.ui, (e) => {
      map.on('mousemove', props.mapbox.layer.features, (e) => {
        const feature = e.features[0];
        if (props.feature && feature.properties.id === props.feature.properties.id) return;
        if (props.feature) {
          // map.setFilter(props.mapbox.layer.ui, ['==', ['get', 'id'], null]);

          map.setFeatureState(props.feature, { hover: false });
        }
        // if (props.popupElement) {
        //   props.popupElement.dataset.feature = feature.properties.id;
        // }

        props.feature = feature;
        map.setFeatureState(feature, { hover: feature.properties.id });
        // map.setFilter(props.mapbox.layer.ui, ['==', ['get', 'id'], feature.properties.id]);

        // if (e.features.length > 0) {
        //   if (hoveredStateId) {
        //     map.setFeatureState(
        //       { source: 'composite', sourceLayer: props.mapbox.layer.ui,  id: hoveredStateId },
        //       { hover: false }
        //     );
        //   }
        //   hoveredStateId = e.features[0].id;
        //   console.log(hoveredStateId)
        //   map.setFeatureState(
        //     { source: 'composite', sourceLayer: props.mapbox.layer.ui, id: hoveredStateId },
        //     { hover: true }
        //   );
        // }
      });
      map.on('mouseleave', props.mapbox.layer.ui, () => {
        // if (props.popupElement) {
        //   delete props.popupElement.dataset.feature;
        // }
        if (props.feature) {
          // map.setFilter(props.mapbox.layer.ui, ['==', ['get', 'id'], null]);
          // map.setFilter(props.mapbox.layer.ui, null);

          map.setFeatureState(props.feature, { hover: false });
        }
        props.feature = null;
      });



      // setTimeout(() => {
      //   const sourceLayer = props.map.getLayer(props.mapbox.layer.features).sourceLayer;
      //   const source = props.map.getSource(sourceLayer);
      //   console.log(source, sourceLayer, props.map);

      //   props.map.addLayer({
      //     id: 'feature-interaction',
      //     type: 'fill-extrusion',
      //     source: sourceLayer,
      //     layout: {},
      //     paint: {
      //       // 'fill-color': '#627BC1',
      //       // 'fill-opacity': [
      //       //   'case',
      //       //   ['boolean', ['feature-state', 'hover'], false],
      //       //   1,
      //       //   0.5
      //       // ],
      //       'fill-extrusion-height': 1200,
      //     }
      //   });  
      // }, 10000)
      
      // props.data.features = new Map();
      // this.queryRenderedFeatures({ layers: [props.mapbox.layerID] }).forEach(feature => props.data.features.set(feature.id, feature.properties));
      // fn.onSearch();
      fn.util.getState();
      fn.onFilter();
    },
    onSearch() {
      if (!props.data.features) return;
      const query = $el.search.value;
      $el.search.dataset.focus = '';
      if (!query) {
        $el.searchResults.innerHTML = '';
        return;
      }

      $el.searchResults.innerHTML = props.data.features.reduce((_, feature) => {
        let searchScore = fn.util.search.score(feature.properties.search, query, true);
        if (searchScore === 0) return _;
        return _.concat({ properties: feature.properties, searchScore });
      }, [])
      .sort((a, b) => b.searchScore - a.searchScore || b.search - a.search)
      .reduce((_, feature) =>
        _.concat(`<li class="meta-item" data-index="${feature.properties.index}">
          <strong>${feature.properties.name || feature.properties.gid}</strong>
          <small>${feature.properties.type || ''}, ${feature.properties.sector} GBR${feature.properties.gbrmpa || feature.properties.keysourcereef ? ' (potential)' : ''}</small>
        </li>`), '');
    },
    onSearchResult(e) {
      const $li = e.target.closest('li');
      if (!$li) return;

      const feature = props.data.features[+$li.dataset.index];

      $el.search.value = feature.properties.name || feature.properties.gid;
      delete $el.search.dataset.focus;

      props.map.easeTo({
        zoom: 10,
        bearing: 0,
        pitch: 40,
        duration: 2000,
        center: feature.geometry.coordinates,
      });
    },
    util: {
      updateState() {
        const hash = [];
        const hashMap = {};
        $el.filters.forEach((filter) => {
          if (filter.checked) {
            const key = (filter.dataset.key || filter.dataset.value).toLowerCase();
            hashMap[key] = hash.length;
            hash.push(key);
          }
        });
        Object.keys(props.colours).forEach((key) => {
          const val = props.colours[key];
          if (hashMap.hasOwnProperty(key)) hash[hashMap[key]] += `:${val}`;
          else {
            hashMap[key] = hash.length;
            hash.push(`_${key}:${val}`);
          }
        });
        $el.ranges.forEach((range) => {
          const values = range.noUiSlider.get().map(v =>
            isNaN(v) ? +v.replace('%', '') : +v);
          if (range.dataset.min != values[0] || range.dataset.max != values[1]) {
            hash.push(`${range.dataset.key}:${values.join(',')}`);
          }
        });
        [ ...$el.colours.querySelectorAll('input[type="checkbox"]:not(:checked)')]
        .forEach((colour) => {
          const key = colour.dataset.key;
          if (hashMap.hasOwnProperty(key)) {
            hash[hashMap[key]] = '!' + hash[hashMap[key]];
          } else {
            hashMap[key] = hash.length;
            hash.push(`!_${key}`);
          }
        });

        history.replaceState(null, '', location.pathname + (hash.length ? '#' + hash.join('|') : ''));
      },
      getState() {
        if (!location.hash) return;
        const hash = location.hash.slice(1);
        props.state = hash.split('|').reduce((_, param) => {
          const split = param.split(':');
          const key = split[0].replace(/[!_]/g, '');
          const value = split[1];
          if (key) {
            _[key] = split[1] || true;
            if (param.charAt(0) === '!') {
              _[key].visible = false;
              props.toggled[key] = true;
            }
            if (value && value.charAt(0) === '#') props.colours[key] = value;
          }
          return _;
        }, {});
        $el.filters.forEach((filter) => {
          const key = (filter.dataset.key || filter.dataset.value).toLowerCase();
          if (props.state[key]) filter.checked = true;
        });
        $el.ranges.forEach((range) => {
          const key = range.dataset.key;
          if (props.state[key]) range.noUiSlider.set(props.state[key].split(','));
        });
      },
      colours(key, colour) {
        if (!props.colours) {
          try {
            props.colours = JSON.parse(localStorage.colours) || {};
          } catch (e) {}
          if (!props.colours) props.colours = {};
          else $el.coloursReset.parentElement.parentElement.dataset.colourised = '';
        }
        if (!colour) return key ? props.colours[key] : props.colours;

        props.colours[key] = colour;
        try {
          localStorage.colours = JSON.stringify(props.colours);
        } catch (e) {}
      },
      debounce(fn, delay) {
        let debounced;
        return (...args) => {
          clearTimeout(debounced);
          debounced = setTimeout(() => fn(...args), delay);
        };
      },
      throttle(fn, delay = 500) {
        let throttled;
        let tailArgs;

        return (...args) => {
          if (throttled) {
            tailArgs = args;
            return;
          }

          throttled = true;
          fn(...args);
          setTimeout(() => {
            throttled = null;
            if (tailArgs) {
              fn(...tailArgs);
              tailArgs = null;
            }
          }, delay);
        };
      },
      getFilters() {
        return $el.filters.reduce((_, filter) => {
          if (filter.checked) {
            _[filter.dataset.type] = [].concat(_[filter.dataset.type] || []).concat({
              title: filter.dataset.title,
              type: filter.dataset.type,
              key: filter.dataset.key,
              value: filter.dataset.value ? filter.dataset.value.split('|') : null,
              colour: (filter.dataset.colour || '').slice(1).split(''),
            });
          }
          return _;
        }, {});
      },
      getRanges() {
        return $el.ranges.reduce((_, range) => {
          const value = range.noUiSlider.get().map(v => isNaN(v) ? +v.replace('%', '') : +v);
          const changed = range.dataset.min != value[0] || range.dataset.max != value[1];
          if (changed) {
            _[range.dataset.type] = {
              title: range.dataset.title,
              type: range.dataset.type,
              value,
            };
          }
          return _;
        }, {});
      },
      search: {
        query(str, query, score) {
          const index = str === query ? 0
          : (!query || !str) && -1
            || str.toLowerCase().indexOf(query.toLowerCase());
          return score
          ? (index < 0
            ? 0
            : (str.length - index + query.length) / (2 * str.length))
          : index; 
        },
        score(str, query, hasAllWords) {
          const strLower = str.toLowerCase();
          const strWords = strLower.split(/\W+/);
          const queryLower = query.toLowerCase();
          const queryWords = queryLower.split(/\W+/);

          return fn.util.search.query(str, query, true) +
          queryWords.reduce((total, queryWord, i) => {
            // exclude previously non-matching queries
            if (hasAllWords && i && !total) return 0;
            // score the query word against the string
            const wordScore = strWords.reduce((subtotal, strWord, ii) => {
              return subtotal || fn.util.search.query(strWord, queryWord, true) / (ii + 1);
            }, 0) / (i + 1);
            // exlude non-matching queries if all words are required
            return hasAllWords && i && !wordScore
            ? 0
            // otherwise sum scores
            : total + wordScore;
          }, 0);
        },
      }
    },
  };

  fn.init();
</script>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: sans-serif;
  font-weight: 300;
}
.map {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
#map {
  width: 100%;
  height: 100%;
}
.filter {
  position: absolute;
  right: 0;
  top: 0;
  margin: 1em;
  max-height: calc(100vh - 8.8em);
  box-sizing: border-box;
  display: flex !important;
}
.filter-items {
  width: 100%;
  margin-top: 2px;
  background: #efefef;
  box-shadow: 0 0.1em 0.1em rgba(0,0,0,0.1);
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
}
.filter-items header {
  padding: 0.75em;
  font-size: 0.8em;
  margin: 0;
  font-weight: 300;
  background: #222;
  color: #CCC;
}
.filter-items--content {
  padding: 0.6em;
}
.filter-items h3 {
  margin: 1em 0 0.4em;
  font-weight: 400;
}
.filter-items h3:first-child {
  margin-top: 0;
}
.filter-items h4 {
  margin: 1.25em 0 0.5em;
  font-size:  0.9em;
}
.filter-items h3 + h4 {
  margin-top: 0.75em;
}
.filter-items label,
.filter-items .label {
  display: block;
  font-size:  0.8em;
}
.filter-colours-key {
  flex-shrink: 1;
  display: flex;
  flex-direction: column;
  overflow: auto;
}
@media (max-height: 75em) {
  .filter[data-filtered] {
    z-index: 0;
  }
  .filter-colours-key {
    position: absolute;
    width: 100%;
    max-height: 100%;
    z-index: -1;
    transition: 0.4s transform;
  }
  .filter-colours-key[data-filtered] {
    transform: translateX(-100%);
  }
}
.filter-colours-key:not([data-filtered]) header {
  display: none;
}
.filter-colours-key header button {
  border: none;
  background: no-repeat;
  color: white;
  font: inherit;
  font-size: 0.75em;
  border-bottom: 1px dotted;
  padding: 0;
  margin-left: 1em;
}
.filter-colours-key:not([data-colourised]) header button {
  display: none;
}
.filter-colours {
  overflow: auto;
  flex-shrink: 1;
  display: flex;
  flex-direction: column;
}
.filter-colours--item {
  padding:  0.6em;
  position: relative;
}
.filter-colours--item[data-toggled] {
  order: 1;
  opacity: 0.5;
}
.filter-colours--item label {
  background: #fffd;
  line-height: 1.4em;
}
.filter-colours--item input[type="color"] {
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  padding: 0;
  border: none;
  height: 1.9em;
  outline: none;
  width: 2em;
  box-shadow: 0 0 0 1px white;
}
.filter-colours--item[data-toggled] input[type="color"] {
  pointer-events: none;
}
.filter-colours--item strong {
  font-weight: 600;
  display: inline-block;
  margin-left:  0.4em;
}
.filter-colours--item span {
  display: inline-block;
  margin-left: 0.5em;
}
.filter-colours--item abbr:hover {
  text-decoration: none;
  line-height: 1em;
}
.search {
  position: absolute;
  left: 0;
  top: 0;
  margin: 1em;
}
.search-input {
  padding: 0.6em 0.4em;
  width: 15em;
  border: none;
  font-size: 1.2em;
  box-shadow: 0 0.1em 0.1em rgba(0,0,0,0.1);
}
.search-results {
  font-size:  0.8em;
  list-style: none;
  margin: 0;
  padding: 0;
  max-height: 10em;
  overflow: auto;
  visibility: hidden;
  transition: 0.1s visibility;
}
.search-input:focus ~ .search-results:not(:empty),
.search-input[data-focus] ~ .search-results:not(:empty) {
  transition: none;
  visibility: visible;
}
.search-results li {
  background: #fff;
  padding:  0.6em;
  border-top: 1px solid rgba(0,0,0,0.1);
  cursor: pointer;
}
.search-results li:hover {
  text-decoration: underline;
}
.meta-item {
  line-height: 1em;
}
.meta-item strong {
  display: block;
  margin-bottom: 0.2em;
}
.popup-hover {
  pointer-events: none;
}
.popup-hover .mapboxgl-popup-content {
  overflow: hidden;
}
.popup-hover .mapboxgl-popup-tip {
  display: none;
}
.popup-hover--feature {

}
.popup-hover--content {
  text-align: center;
  margin-top:  0.4em;
  min-width: 7.5em;
}
.popup-hover--content:not(.popup-hover--feature) {
  background: #222;
  box-shadow: 0 0 0 2em #222;
  color:  #fff;
}
.popup-hover--content h3 {
  font-size: 1.25em;
  display: block;
  margin: 0 0 0.4em;
  font-weight: 300;
}
.popup-hover--content h3 + small {
  /* line-height: 2em; */
  display: block;
  margin-bottom:  1em;
}
.meta {
  position: absolute;
  right: 0;
  top: 0;
  margin: 1em;
}
@media (max-width: 37.5rem) {
  .meta {
    top: auto;
    bottom: 2em;
  }
}
.meta-depth {
  font-weight: 300;
  margin: 0;
  min-width: 1.7em;
  padding-right: 0.9em;
  text-align: right;
}
.meta-depth:empty {
  display: none;
}
.meta-depth::before {
  content: 'Depth:';
  position: absolute;
  transform: translateX(-100%);
  left: 0;
}
.meta-depth::after {
  content: 'm';
  position: absolute;
  right: 0;
}
.mapboxgl-marker svg > g > g:first-child {
  opacity: 0.4;
}
.logo {
  position: absolute;
  bottom:  2em;
  width:  11em;
  fill:  #003556;
  right:  1em;
  z-index: 0;
}
.logo::before {
  content: '';
  position: absolute;
  left: -1em;
  right: -1em;
  top: -0.75em;
  bottom: -0.55em;
  display: block;
  transition: 0.4s transform;
  transform: scaleX(0);
  transform-origin: 100% 0;
  background: #ffffff80;
  z-index: -1;
}
.logo:hover::before {
  transform: scaleX(1);
}
.noUi-target {
  height: 0.5em;
  margin: 0.4em 0 0.75em;
}
.noUi-target .noUi-handle {
  width:  0.8em;
  height:  0.8em;
  top: -0.2em;
  right: -0.4em;
}
.noUi-handle::before,
.noUi-handle::after {
  height: 60%;
  left: 40%;
  transform:  translateX(-50%);
  top:  20%;
  background: #D9D9D9;
}
.noUi-handle::after {
  left: 60%;
}
.noUi-tooltip {
  font-size:  0.65em;
  padding:  4px;
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  transition-duration: 0.2s;
  transition-property: opacity, visibility;
}
.noUi-target:focus-within .noUi-tooltip {
  display: block;
  visibility: visible;
  pointer-events: all;
  opacity: 1;
}
.noUi-connect {
  background: #009dff;
}
.label output {
  font-size: 0.8em;
  font-weight: 300;
}
.label output::after {
  content: '-';
}
.label output:first-of-type::before {
  content: '(';
}
.label output:last-of-type::after {
  content: ')';
}
.c-info {
  position: relative;
  display: inline-block;
  cursor: pointer;
  width: 1em;
  height: 1em;
  font-weight: 300;
  font-size: 0.8rem;
}
.c-info:focus {
  outline: none;
}
.c-info::before {
  content: "\24D8";
  font-size: 0.85em;
}
.c-info em {
  position: absolute;
  left: 50%;
  color: #fff;
  background: #222;
  font-style: normal;
  top: -0.2em;
  transform: translate(-50%, -100%);
  transition-duration: 0.2s;
  transition-property: opacity, transform, visibility;
  width: 16em;
  display: inline-block;
  text-align: center;
  font-size: 0.65rem;
  padding: 0.5em;
  box-shadow: 0.1em 0.1em 0.1em #0000001a;
  z-index: 1;
  opacity: 0;
  visibility: hidden;
  line-height: 1.5;
  font-weight: 300;
}
h3 .c-info em {
  transform: translate(-75%, -100%);
}
.c-info:focus em {
  opacity: 1;
  visibility: visible;
}
#filter-analysis {
  border-top: 1px solid #0000001a;
  background: #0000000a;
  margin: 1em -0.6em -0.6em;
  padding: 1em 0.6em;
}
</style>
</body>